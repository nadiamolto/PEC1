---
output:
  word_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---

# Anáñisis de la expresión en dos líneas celulares empleando microarrays tras el silenciamento del gen DOT1

### Nadia Moltó Lliso


```{r}
require(oligo)
require(arrayQualityMetrics)
library(limma)
require(ReactomePA)
require(Biobase)
require(genefilter)
require(hta20transcriptcluster.db)
require(org.Hs.eg.db)
library("oligo")
library("arrayQualityMetrics")
library("limma")
library("ReactomePA")
library("Biobase")
library("genefilter")
library("hta20transcriptcluster.db") #paquete empleado para el analisis del micoarray empleado en el estudio
library("org.Hs.eg.db") #Anotacion del genoma humano en Entrez

```
```{r}
#Asignación de objeto al archivo CSV que contiene la estructura de los datos a estudiar

targets <- read.csv2("C:/Users/al153/Desktop/MicroarraysAnalysis/datos/targets.csv", header = TRUE, sep = ";") 
knitr::kable(targets, booktabs = TRUE, caption = 'Content of the targets file used for the current analysis')

#Leemos los archivos con la ubicacion exacta dentro del directorio donde estamos trabajando:

celFiles <- list.celfiles("./datos", full.names = TRUE)

#Creamos una variable para las descripciones que tenemos guardadas en el archivo objetivo teniendo en cuenta su formato que es csv y por tanto la separacion entre objetos ";" teniendo en cuenta que en la primera fila tenemos la descripción de cada columna:

my.targets <-read.AnnotatedDataFrame(file.path("./datos","targets.csv"),header=TRUE,row.names=1,sep=";")


#Ahora creamos una variable con los datos de los archivos CEL junto la informacion contenida en el documento targets, obteniendo el Expressionset:

rawData <- read.celfiles(celFiles, phenoData = my.targets)
my.targets@data$Nombre.corto->rownames(pData(rawData))

colnames(rawData) <-rownames(pData(rawData)) 

```


## Abstract

Las líneas celulares PC3 y LNCaP, debido a su procecencia, son habitualmente empleadas para el estudio del cáncer de próstata: su comportamiento a nivel de expresión, las rutas que se ven afectadas o su mecánismo de actuación celular. Varias líneas de investigación relacionan el gen DOT1 con el cáncer de mama o de ovarios, sin embargo, pocos estudios sugieren la relación de este gen con el cáncer de próstata. No obstante, mediante el silenciamento de este gen junto con un análisis de expresión empleando microarrays, es posible ver el efecto de este gen en las líneas celulares cancerosas mencionadas anteriormente.

## Palabras clave
Microarrays, expresión diferencial, R, Bioconductor.


## Objetivos

El objetivo del presente estudio es el de constatar la implicación del gen DOT1 en el desarrollo u evolución del cáncer de próstata mediante la visualización de la expresión diferencial de genes tras silenciarlo en las líneas celulares PC3 y LNCaP.

## Materiales y métodos

Para la obtención de los datos empleados en el presente estudio se hizo uso de la base de datos Omnibus de expresión génica (GEO Gene Expression Obnibus) mantenida por el NCBI [1]. 
La entrada correspondiente a los datos empleados para ello fue la siguiente: GSE135573 [2]. Haciendo uso de la misma, se pudieron descargar los archivos CEL, así como, obtener información acerca de los arrays empleados para el estudio.

Los datos contenidos en los archivos publicados fueron obtenidos experimentalmente a partir de ensayos con microarrays. Según la información facilitada por los autores del experimento, se obtuvieron empleando el array de Affymetrix *GPL17586 [HTA-2_0] Human Transcriptome Array 2.0*, el cual hace uso del material genético contenido en el transcriptoma de las células a emplear.

Se emplearon estos arrays para un total de 12 muestras, incluyendo tres réplicas para cada grupo. 
En concreto, los ensayos se realizaron para dos tipos de tratamiento en cada línea celular (PC3 y LNCaP): Tratamiento control (DMSO) y tratamiento de las líneas celulares con el gen DOT1 inhibido a través del empleo de EPZ004777 (EPZ).

El tratamiento control de ambas líneas celulares fue el dimetil sulfóxido o DMSO, un solvente orgánico que no afecta al nivel de expresión génica. Mientras que para la inhibición de DOT1 se empleó el compuesto EPZ004777. Ambos tratamientos duraron un total de 8 días antes de la extracción del material genético para realizar la hibridación en los arrays. Tras lo cual, se obtuvo un archivo CEL para cada uno de los grupos de muestras.

Una vez se dispuso de los archivos CEL descargados desde la base de datos, se procedió con la creación de un directorio de trabajo en el que se fueron almacenando tanto los archivos empleados como input así como los resultados obtenidos en cada paso del estudio bioinformático.

Por tal de facilitar la comprensión de las órdenes empleadas que se anexan en el *Apéndice I - Creación del entorno* se considera necesario indicar que el directorio "raiz" de trabajo fue "MicroArraysAnalisis" dentro del cual se archivaron los archivos intput en "Datos" y los archivos resultantes u output en el directorio "Resultados".

El programa empleado para ello fue el software R 3.6.3. descargado a través de su página oficial de libre acceso [3] y se empleó, junto con el mismo, el programama RStudio-1.2.5033, el cual, gracias a su interfaz, facilitó la ejecución e interpretación del código R.

Fue de gran importancia, además, el uso de Bioconductor [4], en concreto, la versión 3.10, cuyo método de descarga e instalación puede verse en el *Apéndice I - Creación del entorno*. Bioconductor contiene una serie de paquetes que permiten realizar diferentes tipos de análisis de los datos que se poseen, en este caso, obtenidos mediante microarrays, aunque sus prestaciones son más diversas, no se tratan en el presente estudio.

El procedimiento seguido para el desarrollo de este proyecto siguió una serie de pasos, entre los cuales se encuentran:

**1. Obtención de datos facilitados por los investigadores del estudio a través de GEO tal y como se describe anteriormente.**

**2. Creación de los directorios de trabajo.**

**3. Preparación de los datos.**

Para la preparación de datos, se obtuvo toda la información publicada por los autores en GEO, además del archivo objetivo, que contenía toda la información necesaria para la preparación de los archivos CEL en el entorno de trabajo. 
Para poder integrar los archivos CEL en el entorno de trabajo fue necesario introducir en R los datos crudos de los mismos, para ello se hizo uso del paquete *oligo* de R y se almacenaron en la variable **celFiles**. El siguiente paso fue cargar el archivo objetivo e integrarlo junto con los datos CEL, para esto, se hizo uso de las funciones read.AnnotatedDataframe y read.celfiles, integrándolo todo junto en la variable rawData, con lo cual se dispuso finalmente del ExpressionSet.
Todo ello se describe correctamente en el apartado *Apéndice I - Preparación de datos*.
A continuación se muestran los datos descritos en el expressionset:

Visualización del objeto generado:

```{r}
pData(rawData)
```

Tabla 1: Clasificación de datos en la variable rawData


```{r}
Biobase::exprs(rawData)[1:5, 1:5]
```

Tabla 2: Muestra de datos contenidos en la variable rawData



**4. Control de calidad**

Se realizó un control de calidad de los datos que se acababan de integrar en el espacio de trabajo. El proceso de control de calidad permitió determinar si disponían de la suficiente calidad para realizar el análisis, así como ver si tenían un comportamiento "normal"de las muestras (como por ejemplo que se agruparan según sus grupos experimentales).
Esto se realizó mediante el empleo del paquete ArrayQualityMetrics que permitió obtener un conjunto de archivos con los anáisis de normalidad y que se almacenaron  en la carpeta output "resultados". Este paquete perimitió obtener un conjunto de representaciones de los datos, a la vez que analizar su calidad.

Además de ello, se obtuvo un dendograma para ver la distribución de los datos según el clúster jerárquico, así como un análisis de componentes principales y un diagrama de cajas.

Todo ello, permitió observar el comportamiento de los datos sin procesar, de esta forma se pudo ver si realmente se distribuian según lo esperado o si, por lo contrario, disponían de una muy mala calidad. Esto permitió poder determinar si era necesario corregirlos de alguna forma o eliminar algún dato que se comportara muy diferente con respecto a lo esperado.

Ver *Apéndice I - Control de calidad* para ver las funciones relacionadas con estos pasos.

Los resultados se muestran en el apartado Resultados.

**5. Normalización de los datos**

La normalización de los datos permitió que los datos de Arrays que se habían obtenido pudieran compararse entre si (hasta el momento del estudio solo se habían realizado gráficos representativos por tal de entender la distribución de los datos sin procesar).
La normalizacion puede realizarse mediante el empleo de diferentes metodos, los cuales, tras la realizacion de los mismos van a permitir la eliminacion de los datos que suponen "ruido" o tambien conocido como filtraje.
En este caso se empleó el metodo RMA, muy útil para Arrays de Affymetrix. Este metodo se basa en las sondas PM (perfect match)y no emplea las sondas MM, esto es debido a que este metodo considera que las sondas MM contienen hibridacion especifica e inespecifica y no son utiles al mezclan fondo y señal de hibridacion, es decir, añaden variacion. 
Su procedimiento consiste primeramente en ajuste en las intensidades de fondo o correccion de fondo, normalizacion mediante quantiles (generando  uniformidad en la distribucion de intensidades de los arrays) y transformacion de la intensidad en logaritmos, dando un unico valor para cada grupo de sondas.

Ver funciones en *Apéndice I - Normalización*.

**6. Control de calidad de los datos normalizados**

Por tal de comprobar la calidad de los datos normalizados se realizó nuevamente otro control de calidad de los mismos. Para ello, se realizó un nuevo análisis de componentes principales y un diagrama de cajas.
Los genes que presentaban una varianza inferior al 75% se eliminaron, puesto que se consideró que los genes con una baja v
Los resultados se muestran en el apartado "Resultados" del presente estudio.


**7. Filtracion de genes**

Por tal de hacer una selección de aquellos genes diferencialmente expresados fue necesario eliminar aquellos que presentaban una baja varianza, el motivo es que se espera que los genes que presenten una expresión diferencial con respecto al resto presenten una varianza mayor que aquellos que no lo hagan. No obstante, siempre existe una variabilidad asociada a errores experimentales u otras causas, por ello, se consideró conveniente eliminar aquellos que pudieran tener una variación aleatoria mediante un filtrado de genes por tal de reducir el ruido de fondo en el análisis. [5] Esto permitió que un número elevado de genes incluidos en el análisis con ana variación aleatoria no atribuida al objetivo del proyecto, pudieran ser eliminados y de esta forma, evitar que debido a una gran canitdad de genes, la selección diferencial no fuera truncada.

Por tal de llevar a cabo lo mencionado, se empleó la función nsFilter del paquete bioconductor genefilter, en este caso, se estableció un umbral de varianza para la eliminación de los genes del 75% (ver Apéndice I - Filtración de genes).

**8. Obtención de genes diferencialmente expresados**

Por tal de obtener los genes diferencialmente expresados se siguieron un conjunto de pasos:

**8.1.Creación de la matriz de diseño**

El siguiente paso fue encontrar los genes que esten diferencialmente expresados entre los Microarrays. Para ello, existen diferentes metodos, algunos mas efectivos que otros, cosa que aun es motivo de debate entre la comunidad cientifica. No obstante, en este estudio que empleó el método Modelos lineales para microarrays, implementado en el paquete de limma [6].

Se creó para ello una matriz que contenía tantas filas como muestras (12) y tantas columnas como grupos (4). A su vez, cada fila debía contener un uno en la columna del grupo al que pertenezca la muestra y un cero en el resto.
los comandos empleados se muestran en el *Apéndice I - Obtención de genes diferencialmente expresados*.

**8.2. Comparaciones: Matriz de contrastes**

Una vez se dispuso del modelo lineal generado junto con la matriz de diseño,  se puedieron formular las diferentes preguntas que permitieron encontrar los genes diferencialmente expresados bajo las diferentes condiciones, para ello,se creó la matriz de contrastes, la cual debe disponer de tantas columnas como comparaciones y tantas filas como grupos (como columnas de la matriz de diseño).

En principio, lo que se pretendía con ello, era ver el efecto del tratamiento EPZ para las dos lineas celulares y ver si es diferente al comportamiento control. Para ello, se realizó una matriz de contrastes evaluando: efecto de EPZ en linea celular LNCaP y efecto de EPZ en linea celular PC3.


**8.3. Estimación del modelo y selección de genes**

Disponiendo de la matriz de modelo y de contraste, se realizó la estimación del modelo y realización de contrastes, con ello, se pudo determinar o decidir qué genes se encontraban diferencialmente expresados.
Del mismo modo que para la creacion de la matriz de contrastes, se empleó el paquete limma, el cual se basa en modelos Bayesianos, de forma que permite combinar una estimacion de variabilidad tomando como referencia la matriz generada de forma completa y combinandola con estimaciones individuales de cada valor del que se dispone[7].
Por tal de controlar el porcentaje de falsos positivos que pueden resultar del alto número de contrastes realizados simultáneamente, los valores p se ajustaron con la finalidad de controlar los falsos positivos, segun el metodo de Benjamini y Hochberg [8].
Toda la información obtenida se almacena en el objeto fit.main, según lo indicado en el *Apéndice I - Obtención de genes diferencialmente expresados*.

**8.4. Obtención de listas de genes diferencialmente expresados**

El siguiente paso fue obtener un listado de aquellos genes diferencialmente expresados, para ello, se empleó nuevamente el paquete limma a partir de los datos obtenidos en el punto anterior. Con la funcion TopTable del paquete mencionado, se puede obtener un listado de genes ordenados de mas a menos diferencialmente expresados.
Se obtuvieron para ello, dos tablas en cada uno de los casos estudiados con los genes que estaban más expresados.En estastablas, la primera columna contenía la identificación del fabricante (Affymetrix) para cada conjunto de sondas.

A continuación se generó un volcano plot de los listados obtenidos, según lo mostrado en el apartado Resultados.


**9. Anotacion de genes**

En el punto anterior se obtuvieron los listados de genes diferencialmente expresados, identificados mediante un código del fabricante de las sondas, por tal de determinar a qué gen correspondían los IDs, se procedió con la anotación de los genes.
Por tal de realizar este paso se generaron tablas simplificadas y se anotaron los resultados en nuevos objetos topAnnotated para cada tabla, además se generaron archivos CSV con los resultados, por tal de facilitar cualquier otro análisis que se quisiera realizar sobre estos resultados (ver *Apéndice I - Anotación de genes*).

**10. Comparaciones **

Llegados a este punto, se disponía de tablas con los genes que se expresaban más o menos en las lineas celulares bajo las condiciones qestablecidas, en este caso, bajo tratamiento con EPZ. 
Se procedió a averiguar que genes se encontraban diferencialmente expresados en ambas lineas celulares, para ello se hizo uso de las funciones decideTests y VennDiagramm. Este ultimo, permitió visualizar el diagrama de Venn, una forma de visualizar los genes diferencialmente expresados sin diferenciar entre up y down regulados. 
Para la obtención del diagrama se emplearon los siguientes valores de los parámetros FDR < 0.5 y logFC > 0.5, el motivo es que para realizar análisis de este tipo es necesario incluir un número mínimo de genes para que sea fiable, por ello, se realizó una selección poco restrictiva con unos valores de FDR límite no estrictos.
Para el empleo de la función decideTest que emplearon unos valores de p-value = 0,05 y minimum log2-fold-change required del 0,5.

Mediante el empleo de la función decideTest del paquete limma se obtuvo un objeto con las comparaciones realizadas, disponiendo de tantas filas como genes (diferencialmente expresados) y tantas columnas como comparaciones. 

Los resultados obtenidos se muestran en el apartado Resultados, así como las funciones empleadas en el *Apéndice I - Comparaciones*.

**11. Análisis de significancia biológica**

El análisis de significancia biológica permitió darle sentido biológico a los resultados obtenidos en los pasos anteriores. Permitió ver si a partir del listado de genes diferencialmente expresados que se habían obtenido, había algún proceso biológico o ruta molecular que permitiera obtenrr alguna conclusión sólida con respecto al objetivo del expermiento.

Como primer paso, se preparó la lista de listas de genes a analizar con las ID deEntrez, para ello, se hizo el uso del paquete ReactomePA. 
Fue necesario también incluir como objetos las diferentes entradas a bases de datos de rutas u otras que contengan información sobre los genes. Esta información fue integrada en los resultados obtenidos al emplear el paquete ReactomePA y que se almacenaron en el directorio "Resultados" creado.


##Resultados y discusión


**Control de calidad**

Al realizar el control de calidad de los datos almacenados en nuestro entorno de trabajo, se obtuvieron los siguientes resultados:

Gráfico I: Dendograma obtenido a partir del clúster  jerárquico.
```{r}
library(Biobase)
dist<-dist(t(exprs(rawData)))
hc<-hclust(dist)
plot(hc)

```
Se observa una clasificacion que aunque no es exacta, se aproxima a la realidad. Vemos como las celulas de tipo LNCaP y PC3 si se clasifican en diferentes clusters, no obstante, los tratamientos no aparecen del todo diferenciados.

Mediante el uso del paquete ArrayQualityMetrics se obtuvieron los siguientes gráficos:

En la siguiente tabla se puede realizar la primera toma de contacto con la calidad de los datos obtenidos


******************
Tabla III: Tabla sobre calidad de datos.

Aparentemente, hay una muestra marcada 2 veces con lo cual podria ser problemática, pero se hace necesario ver más pruebas por tal de establecer una decisión al respecto.

Parecen datos comparables entre si, aunque se aprecia que el 8 podria ser outlier puesto que se aleja del resto.


Gráfico II: PCA previa normalización
```{r}
library(ggplot2)
library(ggrepel)
plotPCA3 <- function (datos, labels, factor, title, scale,colores, size = 1.5, glineas = 0.25) {
  data <- prcomp(t(datos),scale=scale)
  # plot adjustments
  dataDf <- data.frame(data$x)
  Group <- factor
  loads <- round(data$sdev^2/sum(data$sdev^2)*100,1) 
  # main plot
  p1 <- ggplot(dataDf,aes(x=PC1, y=PC2)) + theme_classic() + geom_hline(yintercept = 0, color = "gray70") +   geom_vline(xintercept = 0, color = "gray70") + geom_point(aes(color = Group), alpha = 0.55, size = 3) + coord_cartesian(xlim = c(min(data$x[,1])-5,max(data$x[,1])+5)) + scale_fill_discrete(name = "Group")
# avoiding labels superposition
  p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels),segment.size = 0.25, size = size) +  labs(x = c(paste("PC1",loads[1],"%")),y=c(paste("PC2",loads[2],"%"))) +   ggtitle(paste("Principal Component Analysis for: ",title,sep=" "))+  theme(plot.title = element_text(hjust = 0.5)) + scale_color_manual(values=colores)
}

targets <- read.csv("./datos/targets.csv", header = TRUE, sep = ";") 

plotPCA3(exprs(rawData), labels = targets$Nombre.corto, factor = targets$Group, title="Raw data", scale = FALSE, size = 3)

```

En el PCA se aprecia como mas o menos se separan las muestras en 4 grupos, aunque no estan claramente diferenciados. Se tienen a la izquierda la linea celular LNCaP y a la derecha la linea celular PC3 separadas por el primer componente, el cual representa el 66,1% de la variabilidad total, esto se atribuye a la diferencia entre las lineas celulares, lo cual es una buena señal de que efectivamente las dos lineas celulares no se comportan de la misma forma en ninguno de los dos tratamientos.
Por otro lado, el segundo componente representaria un 16,4% de la variabilidad, es el que separaría los grupos de array con tratamiento  y control. 
Aparece tambien de forma confusa la diferencicacion de los tratamientos, pues aparece  por un lado en la linea celular PC3 una de las muestras control en el tratamientoi con EPZ, por otro lado,aparecen intercambios en las lineas LNCaP dos de los tratamientos control y EPZ.

Gráfico II: Diagrama de cajas.

```{r}
boxplot(rawData, cex.axis=0.5, las=2,  which="all",  col = c(rep("red", 3), rep("blue", 3), rep("green", 3), rep("yellow", 3)),main="Distribution of raw intensity values")
```
Vemos un diagrama de cajas de las intensidades de los diferentes Micro arrays.

Pese a que los datos son crudos, se distribuyen de forma mas o menos homogenea, aunque si que hay variaciones notables. Sera necesario  normalizar para obtener un diagrama de cajas mas equilibrado.



**Normalización de datos**

Gráfico III: PCA posterior a la normalización.
```{r}
library(ggplot2)
library(ggrepel)
plotPCA3 <- function (datos, labels, factor, title, scale,colores, size = 1.5, glineas = 0.25) {
  data <- prcomp(t(datos),scale=scale)
  # plot adjustments
  dataDf <- data.frame(data$x)
  Group <- factor
  loads <- round(data$sdev^2/sum(data$sdev^2)*100,1) 
  # main plot
  p1 <- ggplot(dataDf,aes(x=PC1, y=PC2)) + theme_classic() + geom_hline(yintercept = 0, color = "gray70") +   geom_vline(xintercept = 0, color = "gray70") + geom_point(aes(color = Group), alpha = 0.55, size = 3) + coord_cartesian(xlim = c(min(data$x[,1])-5,max(data$x[,1])+5)) + scale_fill_discrete(name = "Group")
# avoiding labels superposition
  p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels),segment.size = 0.25, size = size) +  labs(x = c(paste("PC1",loads[1],"%")),y=c(paste("PC2",loads[2],"%"))) +   ggtitle(paste("Principal Component Analysis for: ",title,sep=" "))+  theme(plot.title = element_text(hjust = 0.5)) + scale_color_manual(values=colores)
}

targets <- read.csv("./datos/targets.csv", header = TRUE, sep = ";") 

plotPCA3(exprs(rawData), labels = targets$Nombre.corto, factor = targets$Group, title="Raw data", scale = FALSE, size = 3)
```
El gráfico PCA permite ver como el primer componente representa el 82% de la variabilidad, en comparacion con la PCA de los datos crudos que explicaba el 66,1%, la variabilidad explicada ha aumentado notablemente, en este caso se separan las lineas celulares, igual que en el caso de la anterior P^CA.
En cambio el segundo componente representa mucha menos variabilidad que en los datos sin normalizar, el cual es el que separa los arrays procedentes de celulas control y de las tratadas con EPZ.

Vemos como, del mismo modo que ocurria en la anterior PCA, hay una muestra de PC3.EPZ intercambiada con una de PC3.DMSO, podria ser una errata en el etiquetaje, aunque la proximidad entre muestras con respecto a la componente principal 2 que separa grupos de tratamientos, podria ser indicativo de que no lo es.
Si observamos la linea celular LNCaP si que hay una clara diferencia entre tratamientos.

El siguiente paso es el filtraje o cribado de aquellos genes que presentan baja variabilidad, puesto que estamos buscando aquellos diferencialmente expresados bajo las diferentes condiciones presentadas. PAra ello, eliminaremos aquellos genes que presenten una varianza mas baja, pues suponemos que aquellos genes con mayor variabilidad presentan mayor varianza con respecto del resto.


Gráfico IV: Diagrama de barras posterior a la normalización.

```{r}
eset_rma <- rma(rawData)

boxplot(eset_rma, cex.axis=0.5, las=2,  which="all",  col = c(rep("red", 3), rep("blue", 3), rep("green", 3), rep("yellow", 3)),main="Distribution of normalized values")
```
Ahora vemos un diagrama de cajas de las intensidades normalizados y sumarizadas, donde la intensidad de los Arrays se distribuye en todos uniformemente y las cajas son exactamente iguales, esto seria un sintoma de una buena normalizacion.

**Obtención de genes diferencialmente expresados**


```{r}
if (!exists("eset_filtered")) load (file="./resultados/normalized.Data.Rda") #Ahora empleamos el archivo generado tras la normalizacion de los datos y el filtraje de los genes

designMat<- model.matrix(~0+Grupo, pData(eset_filtered))
colnames(designMat) <- c("LNCAP.DMSO", "LNCAP.EPZ", "PC3.DMSO", "PC3.EPZ")
print(designMat)
print(designMat)

```
Tabla II: Matriz de diseño del experimento.

La matriz de diseño permite ver las diferentes comparaciones a realizar. Se observa como tenemos 4 grupos de datos diferenciales: dos grupos para cada línea celular, de los cuales, uno contiene el tratamiento con EPZ y el otro es el control.

Tras la obtención de los genes diferencialmente expresados se obtienen las siguientes tablas:

```{r}
cont.matrix <- makeContrasts (LNCAPvsEPZ = LNCAP.EPZ-LNCAP.DMSO,
                              PC3vsEPZ = PC3.EPZ-PC3.DMSO,
                                levels=designMat)

fit<-lmFit(eset_filtered, designMat)
fit.main<-contrasts.fit(fit, cont.matrix)
fit.main<-eBayes(fit.main)


toptab.LNCAPvsEPZ <- topTable (fit.main, number=nrow(fit.main), coef="LNCAPvsEPZ", adjust="fdr")
head(toptab.LNCAPvsEPZ)

```
Tabla III: Lista de genes diferencialmente expresados para la línea celular LNCaP.


```{r}
toptab.PC3vsEPZ <- topTable (fit.main, number=nrow(fit.main), coef="PC3vsEPZ", adjust="fdr")
head(toptab.PC3vsEPZ)
```
Tabla IV: Lista de genes diferencialmente expresados para la línea celular PC3.
Donde:
logFC: Diferencia media entre grupos.
AveExpr: Expresión media de todos los genes que se han comparado.
t : Prueba t moderada.
P.Value: Prueba valor p.
adj.P.Val: Valor p ajustado según Benjamini y Hochberg ( 1995 ).
B: Estadística B: probabilidades de registro posterior del gen de ser vs no ser diferencial expresado.



Se muestra a continuación el volcano plot de los genes diferencialmente expresados:

Gráfico V: Volcanoplot de los genes diferencialmente expresados.
```{r}

geneSymbols <- select(hta20transcriptcluster.db, rownames(fit.main), c("SYMBOL"))
SYMBOLS<- geneSymbols$SYMBOL
volcanoplot(fit.main, coef=1, highlight=4, names=SYMBOLS, main=paste("Differentially expressed genes", colnames(cont.matrix)[1], sep="\n"))
abline(v=c(-1,1))

```


Este grafico permite ver una representación gráfica de los genes ordenados donde en la escala horizontal se representa el cambio entre dos grupos y la escala vertical el p valor de cada test en escala logaritmica negativa, siendo los p valores mas pequeños los que aparecen arriba. 
Así pues, se podría considerar que el eje horizontal indicaría el impacto biologico del cambio entre los grupos (a mayor fold change, mayor impacto) y el vertical mostraria la fiabilidad del cambio mediante el empleo del P-valor obtenido en el test t.
Lo que, en colclusión, significaria que los genes diferencialmente expresados y significativos, serian los que aparecen arriba con un menor p-valor, los cuales se marcan en azul.


das al mismo tratamiento, parte de los genes diferencialmente expresados se encuentren en ambas. 
Es probable que estos sean los genes que mayor interes presenteN, puesto que serian los que probablemente participen en el retraso o anulacion de la apoptosis celular en celulas cancerosas. No obstante, seria necesario estudiar ambas lineas celulares, de forma que se determine, cual de ellas es mas resistente a apoptosis bajo este tratamiento, en ese caso, buscariamos los genes diferencialmente expresados en una de la linea con respecto a la otra. Este proceso no se puede realizar en el presente estudio porque faltarian datos experimentales como el tiempo hasta la muerte celular.

En este caso, se procede a averiguar que genes se encuentran diferencialmente expresados en ambas lineas celulares, para ello se hara uso de los paquetes decideTests y VennDiagramm. Esta ultima permitira visualizar el diagrama de Venn, una forma de visualizar los genes diferencialmente expresados sin diferenciar entre up y down regulado

Gráfico VI:
```{r}
res<-decideTests(fit.main, method="separate", adjust.method="fdr", p.value=0.5, lfc=0.5)

sum.res.rows<-apply(abs(res),1,sum)
res.selected<-res[sum.res.rows!=0,] 


vennDiagram (res.selected[,1:2], cex=0.9)
title("Genes in common between the three comparisons\n Genes selected with FDR < 0.5 and logFC > 0.5")

```
El diagrama de Venn muestra como existen varios genes diferencialmente expresados en cada uno de los grupos, 5 de los cuales coinciden en ambos. Realmente, es probable que estos sean los genes realmente importantes debido a que el presente estudio trata de determinar, entre dos líneas celulares de cáncer de próstata, qué genes hay diferencialmente expresados si se silencia el gen DOT1 relacionado con este tipo de cáncer.

Tras la ejecución del paquete ReactomePA de los datos obtenidos en el cribado anterior

**Anotacion de genes**


## Apéndice I:

Listado de paquetes empleados:

```{r}
require(oligo)
require(arrayQualityMetrics)
library(limma)
require(ReactomePA)
require(Biobase)
require(genefilter)
require(hta20transcriptcluster.db)
require(org.Hs.eg.db)
library("oligo")
library("arrayQualityMetrics")
library("limma")
library("ReactomePA")
library("Biobase")
library("genefilter")
library("hta20transcriptcluster.db") #paquete empleado para el analisis del micoarray empleado en el estudio
library("org.Hs.eg.db") #Anotacion del genoma humano en Entrez

```

**1. Creación del entorno**

Instalación de Bioconductor:

```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install()
```

Creación de directorios:

```{r}
setwd("C:/Users/al153/Desktop/MicroarraysAnalysis")
#Creamos el archivo donde guardaremos los datos proporcionados
dir.create("datos")
dir.create("resultados")

```

**2. Preparación de datos**

Lectura de los archivos CEL y asignación de los mismos a la variable rawData mediante el empleo de la función list.celfiles del paquete oligo:

```{r}
#Asignación de objeto al archivo CSV que contiene la estructura de los datos a estudiar

targets <- read.csv2("C:/Users/al153/Desktop/MicroarraysAnalysis/datos/targets.csv", header = TRUE, sep = ";") 
knitr::kable(targets, booktabs = TRUE, caption = 'Content of the targets file used for the current analysis')

#Leemos los archivos con la ubicacion exacta dentro del directorio donde estamos trabajando:

celFiles <- list.celfiles("./datos", full.names = TRUE)

#Creamos una variable para las descripciones que tenemos guardadas en el archivo objetivo teniendo en cuenta su formato que es csv y por tanto la separacion entre objetos ";" teniendo en cuenta que en la primera fila tenemos la descripción de cada columna:

my.targets <-read.AnnotatedDataFrame(file.path("./datos","targets.csv"),header=TRUE,row.names=1,sep=";")


#Ahora creamos una variable con los datos de los archivos CEL junto la informacion contenida en el documento targets, obteniendo el Expressionset:

rawData <- read.celfiles(celFiles, phenoData = my.targets)
my.targets@data$Nombre.corto->rownames(pData(rawData))

colnames(rawData) <-rownames(pData(rawData)) 

```

**3. Control de calidad**

Instalación de ArrayQualityMetrics y análisis del expressionset:

```{r}
 #Este paquete nos permitira realizar observar los datos que disponemos y realizar un control de calidad de los mismos. Si no se dispone de un ordenador bastante capacidad (como es el caso) el comando podra demorar mucho, incluso no llegar a funcionar correctamente.
#arrayQualityMetrics(rawData)


```


**4.Normalización de los datos**

```{r}
eset_rma <- rma(rawData)

```

Obtención del gráfico de PCA:
```{r}

plotPCA3(exprs(eset_rma), labels = targets$Nombre.corto, factor = targets$Group, title="Raw data", scale = FALSE, size = 3)
```


**5. Filtración de genes**
```{r}

annotation(eset_rma) <- "hta20transcriptcluster.db"
filtered <- nsFilter(eset_rma, 
                     require.entrez = TRUE, remove.dupEntrez = TRUE, 
                     var.filter=TRUE, var.func=IQR, var.cutoff=0.75, 
                     filterByQuantile=TRUE, feature.exclude = "^AFFX") #Se filtran aquellos con una varianza inferior al 75%

print(filtered$filter.log)

save(eset_rma, eset_filtered, file="./resultados/normalized.Data.Rda") #Guardamos los datos

eset_filtered <-filtered$eset
print(eset_filtered)
```

**6. Obtención de genes diferencialmente expresados**

Generación de la matriz de diseño:

```{r}
if (!exists("eset_filtered")) load (file="./resultados/normalized.Data.Rda") #Ahora empleamos el archivo generado tras la normalizacion de los datos y el filtraje de los genes

designMat<- model.matrix(~0+Grupo, pData(eset_filtered))
colnames(designMat) <- c("LNCAP.DMSO", "LNCAP.EPZ", "PC3.DMSO", "PC3.EPZ")
print(designMat)

```

Obtención de la matriz de ontrastes:

```{r}
cont.matrix <- makeContrasts (LNCAPvsEPZ = LNCAP.EPZ-LNCAP.DMSO,
                              PC3vsEPZ = PC3.EPZ-PC3.DMSO,
                                levels=designMat)
print(cont.matrix)

```


Estimación del modelo y selección de genes:

```{r}
fit<-lmFit(eset_filtered, designMat)
fit.main<-contrasts.fit(fit, cont.matrix)
fit.main<-eBayes(fit.main)
class(fit.main)
```


Obtención de listas de genes diferencialmente expresados:

```{r}
#Lista de genes para la primera comparacion realizada en la matriz de contrastes:

toptab.LNCAPvsEPZ <- topTable (fit.main, number=nrow(fit.main), coef="LNCAPvsEPZ", adjust="fdr")
head(toptab.LNCAPvsEPZ)

```

```{r}
#Lista para la segunda comparacion de la matriz de contratses:
toptab.PC3vsEPZ <- topTable (fit.main, number=nrow(fit.main), coef="PC3vsEPZ", adjust="fdr")
head(toptab.PC3vsEPZ)

```



Obtención del volcano plot:

```{r}

geneSymbols <- select(hta20transcriptcluster.db, rownames(fit.main), c("SYMBOL"))
SYMBOLS<- geneSymbols$SYMBOL
volcanoplot(fit.main, coef=1, highlight=4, names=SYMBOLS, main=paste("Differentially expressed genes", colnames(cont.matrix)[1], sep="\n"))
abline(v=c(-1,1))

```


**7.Anotación de genes**

```{r}
#Se genera la funcion para obtener la tabla simpificada
annotatedTopTable <- function(topTab, anotPackage){ 
  topTab <- cbind(PROBEID=rownames(topTab), topTab)
  myProbes <- rownames(topTab)
  thePackage <- eval(parse(text = anotPackage))
  geneAnots <- select(thePackage, myProbes, c("SYMBOL", "ENTREZID", "GENENAME"))
  annotatedTopTab<- merge(x=geneAnots, y=topTab, by.x="PROBEID", by.y="PROBEID")
  return(annotatedTopTab)}
```

 
```{r}
#Se emplea la funcion para cada una de las dos tablas obtenidas anteriormente
topAnnotated_LNCAPvsEPZ <- annotatedTopTable(toptab.LNCAPvsEPZ,anotPackage="hta20transcriptcluster.db")
topAnnotated_PC3vsEPZ <- annotatedTopTable(toptab.PC3vsEPZ,anotPackage="hta20transcriptcluster.db")
write.csv(topAnnotated_LNCAPvsEPZ, file="./resultados/topAnnotated_LNCAPvsEPZ.csv")
write.csv(topAnnotated_PC3vsEPZ, file="./resultados/topAnnotated_PC3vsEPZ.csv")

#Generación de archivos CSV con los resultados.

```


**8.Comparaciones**

```{r}
res<-decideTests(fit.main, method="separate", adjust.method="fdr", p.value=0.5, lfc=0.5)
```


Genes diferencialmente expresados up-regulated y down-regulated:

```{r}
sum.res.rows<-apply(abs(res),1,sum)
res.selected<-res[sum.res.rows!=0,] 
print(summary(res))
```

Diagrama de Venn:

```{r}
#vennDiagram (res.selected[,1:3], cex=0.9)
#title("Genes in common between the three comparisons\n Genes selected with FDR < 0.5 and logFC > 0.5")

```



**9.Análisis de significancia biológica**

Preparación de listado de genes diferencialmente expresados:

```{r}


listOfTables <- list(LNCAPvsEPZ = toptab.LNCAPvsEPZ, 
                     PC3vsEPZ  = toptab.PC3vsEPZ)

listOfSelected <- list()
for (i in 1:length(listOfTables)){
  topTab <- listOfTables[[i]]
  whichGenes<-topTab["adj.P.Val"]<0.3 
  selectedIDs <- rownames(topTab)[whichGenes] # Generamos el ID a Entrez
  EntrezIDs<- select(hta20transcriptcluster.db, selectedIDs, c("ENTREZID"))
  EntrezIDs <- EntrezIDs$ENTREZID
  listOfSelected[[i]] <- EntrezIDs
  names(listOfSelected)[i] <- names(listOfTables)[i] 
  }
sapply(listOfSelected, length)
```


Establecimiento del universo con todos los genes del genoma humano:

```{r}
mapped_genes2GO <- mappedkeys(org.Hs.egGO) 
mapped_genes2KEGG <- mappedkeys(org.Hs.egPATH)
mapped_genes <- union(mapped_genes2GO , mapped_genes2KEGG)
```


Significancia biológica:

```{r}

listOfData <- listOfSelected[1:2]
comparisonsNames <- names(listOfData)
universe <- mapped_genes

for (i in 1:length(listOfData)){
  genesIn <- listOfData[[i]]
  comparison <- comparisonsNames[i]
  enrich.result <- enrichPathway(gene = genesIn ,pvalueCutoff = 0.05,readable = T,pAdjustMethod = "BH",organism = "human",universe = universe)
  
cat("##################################")

cat("\nComparison: ", comparison,"\n")
print(head(enrich.result))

if (length(rownames(enrich.result@result)) != 0) {
  write.csv(as.data.frame(enrich.result), 
            file =paste0("./resultados/","ReactomePA.Results.",comparison,".csv"), row.names = FALSE)
  
pdf(file=paste0("./resultados/","ReactomePABarplot.",comparison,".pdf"))
print(barplot(enrich.result, showCategory = 15, font.size = 4, title = paste0("Reactome Pathway Analysis for ", comparison,". Barplot")))

dev.off()

pdf(file = paste0("./resultados/","ReactomePAcnetplot.",comparison,".pdf"))
print(cnetplot(enrich.result, categorySize = "geneNum", schowCategory = 15, vertex.label.cex = 0.75))
dev.off()}
}

```


```{r}
cnetplot(enrich.result, categorySize = "geneNum", schowCategory = 15,  vertex.label.cex = 0.75)
```


